歡迎來到這份深度技術筆記。我是你們的資深技術導師，今天我們將深入探討 **ADK 雙向串流 (Bidi-streaming)** 應用程式生命週期的起點——**階段 1：應用程式初始化**。

在開發即時 AI 代理程式時，「階段 1」是整體的戰略基石。與傳統應用程式不同，串流應用的架構更強調組件的重用性與關注點分離。在這一階段，我們會建立一些**全域共享**的基礎設施，它們在應用程式啟動時僅執行一次，卻決定了後續所有使用者連線的智慧程度與穩定性。

---

### 📌 階段 1：初始化學習地圖

1.  **戰略定位**：為什麼初始化組件是「全域共享」且「無狀態」的？
2.  **核心組件拆解**：
    *   **Agent**：定義 AI 的個性、模型與工具箱。
    *   **SessionService**：跨越時空的對話記憶管理。
    *   **Runner**：驅動雙向串流的執行引擎。
3.  **邏輯具象化**：初始化組件的職責與狀態對照。
4.  **代碼即真理**：實戰中的初始化範例與導師點評。
5.  **知識延伸**：生產環境中的 Session 持久化選擇。

---

### 一、 戰略定位：構建「一次性」的基礎設施

在 ADK 架構中，階段 1 的目標是建立一組不隨個別使用者連線而變動的組件。

**這代表什麼？**
想像你在運作一個大型電商平台的購物管家。你不需要為每個進入網站的使用者重新訓練一個 AI 或重新建立一個執行引擎。
*   **關鍵在於**：Phase 1 的組件（如 Agent 和 Runner）是**無狀態且可重用**的。
*   **技術優勢**：這樣做能將數個月的基礎設施開發（連線管理、工具編排、狀態持久化）減少為簡單的**宣告式配置**。

---

### 二、 三大基石組件詳解

根據來源資料，我們在初始化階段必須定義三個核心組件：

#### 1. Agent：AI 的靈魂
Agent 是應用的核心，它定義了 AI 可以做什麼、表現如何，以及由哪個模型驅動。
*   **配置項**：包括特定模型（如原生音訊模型）、指令（System Instructions）以及可用的工具（如 Google 搜尋）。
*   **導師提示**：在代碼中，`Agent` 是 `LlmAgent` 的建議簡寫，兩者在功能上是完全相同的。

#### 2. SessionService：記憶的管理者
每個即時對話都需要上下文。`SessionService` 負責管理這些對話執行緒，實現對話恢復與上下文持久化。
*   **職責**：用於獲取或建立 ADK Session。
*   **開發建議**：開發階段可使用 `InMemorySessionService`（重啟即消失）；生產環境則必須考慮持久化選項。

#### 3. Runner：架構的指挥家
Runner 為 Agent 提供執行環境。它管理對話流、協調工具執行，並提供關鍵的 `run_live()` 介面。
*   **關鍵參數**：`app_name` 是必需的，用於在儲存服務中識別你的應用程式，將所有對話組織在該名稱之下。

---

### 三、 邏輯具象化：組件職責對照表

我們透過 Markdown 表格來解構這三個組件的特性，幫助你強化視覺記憶：

| 組件名稱 | 核心職責 | 狀態屬性 | 生存週期 |
| :--- | :--- | :--- | :--- |
| **Agent** | 定義行為、個性、模型與工具 | 無狀態 (Stateless) | 啟動時建立一次，全域共享 |
| **SessionService** | 儲存/檢索對話歷史與狀態 | 持久性管理 (Persistent) | 啟動時建立一次，全域共享 |
| **Runner** | 編排對話、執行工具、提供 `run_live()` | 執行引擎 (Execution Engine) | 啟動時建立一次，全域共享 |

---

### 四、 代碼即真理：初始化實戰

以下是來源資料中具備生產級參考價值的 FastAPI 初始化實作。請注意導師對這些代碼的畫線點評：

```python
# [導師點評]：Phase 1 的核心在於全域初始化。
# 這些變數定義在 FastAPI 路由之外，確保它們在啟動時載入一次。

# 1. 建立 SessionService
# 開發環境使用 InMemory，生產環境建議改用 DatabaseSessionService
session_service = InMemorySessionService()

# 2. 建立 Runner
# 注意：必需傳入 APP_NAME，這是對話儲存的根標籤
# 這裡傳入了從 agent.py 匯入的 agent 實例
runner = Runner(app_name=APP_NAME, agent=agent, session_service=session_service)

# [關鍵在於]：此時我們尚未處理任何 WebSocket 連線，
# 我們只是為即將到來的雙向串流搭好舞台。
```

#### 💡 場景驅動教學：模型載入
**問：** 「如果我在 `.env` 檔案中更改了模型名稱，我需要重寫初始化邏輯嗎？」
**解析：** 不需要。來源資料建議使用環境變數（如 `DEMO_AGENT_MODEL`）來配置模型。這提供了**平台靈活性**，讓你只需更改配置就能在 Gemini Live API（開發）與 Vertex AI Live API（生產）之間無縫切換，而無需更改應用程式代碼。

---

### 五、 知識延伸與收斂：生產環境的持久化策略

在 Phase 1 初始化 `SessionService` 時，你對持久化方案的選擇將決定應用的擴展能力：

1.  **DatabaseSessionService**：
    *   **場景**：需要完全控制數據儲存（如 SQLite, PostgreSQL, MySQL）。
    *   **價值**：適合單伺服器或自託管的多伺服器部署。
2.  **VertexAiSessionService**：
    *   **場景**：已在使用 Google Cloud Platform。
    *   **價值**：具備內建可擴展性的託管儲存，與 Vertex AI 功能緊密整合。

**實戰導向總結：**
階段 1 的初始化是為了讓你的應用程式具備「代理程式意識」。透過建立**全域共享**的 `Agent`、`SessionService` 與 `Runner`，你已經完成了一大半的工作。接下來，當 WebSocket 連線進來時，系統只需調用這些已就緒的組件來初始化特定的使用者會話即可。

#GoogleADK #AIAgent #ApplicationLifecycle #SystemArchitecture #BidiStreaming

**延伸學習建議**：完成 Phase 1 後，請前往《第 2 部分：對話執行緒初始化》，學習如何使用這些組件為特定使用者建立 `LiveRequestQueue`。