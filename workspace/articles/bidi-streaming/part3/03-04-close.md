在 Google 代理程式開發套件 (ADK) 的架構中，訊息傳遞 (Upstream) 不僅包含文字、音訊與影像的傳輸，更包含了一種至關重要的控制訊號：**優雅關閉 (Close)**。

作為你的資深技術導師，我必須強調：在雙向串流 (Bidi-streaming) 的實戰中，如何「開始」一段對話固然迷人，但如何「結束」一段對話才真正體現了生產級應用的專業度。若忽略了這一步，你的系統將面臨資源枯竭的風險。

---

### 📌 控制訊號：優雅關閉 (Close) 學習地圖

1.  **核心定義**：為什麼 `close()` 是上游流程的最終守護者？
2.  **技術運作機制**：從 `LiveRequestQueue` 到 Live API 的訊號鏈結。
3.  **生產環境的代價**：解構「殭屍會話」與配額陷阱。
4.  **代碼實戰模式**：使用 `finally` 區塊實現 100% 的資源清理。
5.  **模式對比**：BIDI 模式與 SSE 模式在關閉邏輯上的根本差異。

---

### 一、 核心定義：優雅關閉的戰略價值

在 ADK 的四階段生命週期中，「階段 4：終止 Live API 對話」的核心動作就是發送關閉訊號。

**這代表什麼？**
優雅關閉不僅僅是停止程式碼運作，它是一種明確的指令，通知 Live API 後端乾淨地終止 WebSocket 連線並釋放該會話所占用的雲端資源。在 BIDI 模式（雙向串流）下，這是開發者的**手動責任**。

---

### 二、 技術運作機制：訊號是如何傳遞的？

當你在應用程式中呼叫 `live_request_queue.close()` 時，底層發生了以下連鎖反應：

1.  **訊號封裝**：ADK 會建立一個帶有 `close=True` 標誌的 `LiveRequest` 容器。
2.  **佇列傳遞**：該訊號被推入 `LiveRequestQueue` 佇列的末端。
3.  **迴圈結束**：此訊號會指示 `run_live()` 非同步產生器停止產生事件，並優雅地退出產生器迴圈。
4.  **後端斷開**：訊號傳抵 Live API，模型完成當前處理並關閉連線。

---

### 三、 邏輯具象化：BIDI vs. SSE 的終止邏輯差異

理解不同串流模式下的關閉機制，能幫助你避免常見的連線錯誤。

| 模式分類            | 終止權責           | 運作機制                                                                    |
| :------------------ | :----------------- | :-------------------------------------------------------------------------- |
| **BIDI (雙向串流)** | **開發者手動關閉** | 應用程式需在會話結束或發生錯誤時，主動呼叫 `close()`。                      |
| **SSE (單向串流)**  | **ADK 自動關閉**   | 當 ADK 收到模型的 `turn_complete=True` 事件時，會自動對佇列呼叫 `close()`。 |

---

### 四、 場景驅動教學：預防「殭屍會話」的配額陷阱

**提問：** 「導師，如果我的 WebSocket 客戶端直接斷開連線，我還需要呼叫 `close()` 嗎？」

**解析：**
**絕對需要。** 來源資料明確警告，如果你不呼叫 `close()`，雖然本地資源會被清理，但 Live API 將會收到一個「意外斷開」而非優雅訊號。
*   **關鍵在於**：這會導致「殭屍會話 (Zombie Sessions)」在雲端保持開啟直到超時。
*   **生產事故**：這些滯留的會話會持續計入你的**並行會話配額**（Gemini 視層級為 50-1,000 個；Vertex AI 為高達 1,000 個）。如果殭屍會話過多，新使用者將因配額不足而無法連線。

---

### 五、 代碼即真理：生產級終止模式

在 Bidi-demo 的實作中，終止邏輯必須被包裹在 `finally` 區塊中。這確保了無論是正常結束還是發生異常，關閉訊號都能被發送。

```python
# [導師點評]：這是 Phase 4 的黃金準則。
# 無論 upstream 或 downstream 任務發生什麼，我們都必須清理資源。

try:
    # 啟動並行任務處理雙向串流
    await asyncio.gather(upstream_task(), downstream_task())

except WebSocketDisconnect:
    logger.debug("Client disconnected normally")

except Exception as e:
    logger.error(f"Unexpected error in streaming tasks: {e}", exc_info=True)

finally:
    # ========================================
    # Phase 4: Session Termination
    # ========================================
    # [關鍵在此]：永遠要關閉佇列，以發出終止 Live API 對話的訊號
    # 這能最大限度地減少並行會話名額的消耗
    logger.debug("Closing live_request_queue")
    live_request_queue.close() #
```

---

### 💡 知識延伸與總結

在更大的訊息傳遞脈絡下，`close()` 訊號是 `LiveRequestQueue` 唯一具備「自我終結」特性的成員。

**導師實戰總結：**
*   **不重複使用**：關閉訊號會保留在隊列中。如果你嘗試在多個 `run_live()` 呼叫中重複使用同一個 `LiveRequestQueue`，新會話會因為讀取到舊的關閉訊號而立即終止。
*   **配額保護**：在生產環境中，`close()` 是你最有效的成本與配額控制工具。
*   **非同步安全性**：`close()` 是同步方法，可以在非同步程式碼中隨時呼叫而無需 `await`，這簡化了在異常處理流程中的調用難度。

掌握了優雅關閉，你才真正掌握了 ADK 雙向串流的完整運作機制，確保你的代理程式應用能夠健康、長久地在雲端環境中運行。

🏷️ `adk-streaming`, `graceful-termination`, `live-request-queue`, `quota-management`, `bidi-lifecycle`

---

[← 上一頁](./03-03-vad.md) | [下一頁 (Part 4) →](../part4/04-00-downstream.md) | [課程首頁 ↩](../COURSE_PLAN.md)