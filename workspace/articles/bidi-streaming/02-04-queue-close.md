歡迎來到這份深度技術筆記的最後一站。我是你們的資深技術導師。

我們已經走過了全域初始化、會話建立以及最精彩的並行事件處理。現在，我們來到了決定應用程式是否能穩定運作、且不浪費成本的關鍵關卡：**階段 4：終止會話 (Session Termination)**。

在更大的應用程式生命週期脈絡下，終止階段不只是程式碼的結尾，它是**資源管理的最後防線**。如果沒有處理好這一步，你的應用程式在生產環境中很快就會因為資源耗盡而崩潰。

---

### 📌 階段 4：終止會話學習地圖

1.  **終止階段的核心使命**：為什麼 `close()` 是生產級應用的生命線？
2.  **`LiveRequestQueue.close()` 的運作機制**：從「關閉訊號」到「結束迴圈」。
3.  **殭屍會話 (Zombie Sessions)**：不進行優雅終止的代價與配額陷阱。
4.  **實戰代碼演練**：利用 `finally` 區塊確保 100% 的資源清理。
5.  **跨模式對比**：BIDI 手動終止 vs. SSE 自動終止。

---

### 一、 終止階段的核心使命：不只是結束，而是「釋放」

在 ADK 的生命週期中，當對話完成、使用者中斷連線或發生逾時後，我們必須主動告知系統：這個串流已經結束了。

**這代表什麼？**
當我們進入階段 4，核心動作是呼叫 `live_request_queue.close()`。這個動作具備兩層技術意義：
*   **本地端**：指示 `run_live()` 非同步產生器停止產生事件，並退出迴圈。
*   **雲端 (Live API)**：向後端發送優雅終止訊號，讓模型完成正在進行的處理並關閉連線。

---

### 二、 邏輯具象化：未終止的災難——「殭屍會話」

很多初學者會忽略階段 4，認為使用者斷開連線後資源會自動回收。但在雙向串流的世界裡，這是一個極其危險的誤區。

#### ⚠️ 殭屍會話與配額陷阱對照表
| 狀態 | 優雅終止 (呼叫 `close()`) | 未優雅終止 (遺漏 `close()`) |
| :--- | :--- | :--- |
| **雲端狀態** | Live API 立即關閉會話 | 變成「殭屍會話」，在雲端保持開啟直到超時 |
| **配額消耗** | 立即釋放並行會話名額，供下位使用者使用 | **持續計入配額**，直到最終超時為止 |
| **可規模化性** | 高，能處理最大並行連線數 | 低，並行會話數會因殭屍佔位而迅速枯竭 |
| **費用/成本** | 精確計費 | 可能產生不必要的資源佔用開銷 |

**關鍵點在於：** 雖然 ADK 會自動清理本地資源，但若不主動呼叫 `close()`，Live API 將會收到一個「意外斷開連線」，而非優雅關閉。這會顯著減少你的應用程式能同時服務的使用者數量。

---

### 三、 實戰代碼：程式碼即真理

在生產級架構中，終止邏輯必須被包裹在一個「保證執行」的結構中。以下是來源資料中提供的 FastAPI 實作模式，請注意我對 `finally` 區塊的導師註解：

```python
# [導師點評]：這是 Phase 4 的標準模板。
# 無論上游或下游任務發生了什麼（斷開連線、異常、或結束），
# 我們都必須確保資源被清理。

try:
    # 階段 3：執行並行任務
    logger.debug("開始處理上游與下游任務...")
    await asyncio.gather(upstream_task(), downstream_task())

except WebSocketDisconnect:
    logger.debug("用戶端正常斷開連線") # 這是 Phase 4 常見的觸發點

except Exception as e:
    logger.error(f"串流任務發生非預期錯誤: {e}", exc_info=True)

finally:
    # [核心原則]：Phase 4 - 終止會話
    # 永遠在 finally 中關閉隊列，這會發出終止 Live API 對話的訊號
    logger.debug("正在關閉 live_request_queue...")
    live_request_queue.close()
    # [這代表什麼？]：這會讓 run_live() 停止產生事件並乾淨地退出迴圈。
```

---

### 四、 深入配置：不同模式下的終止行為

在 `RunConfig` 的脈絡下，串流模式 (StreamingMode) 決定了終止的職責。

*   **BIDI 模式 (雙向串流)**：這是本指南的重點。你的應用程式**負有完全的責任**，必須在會話終止或發生錯誤時手動呼叫 `close()` 以最小化資源使用量。
*   **SSE 模式 (單向串流)**：這屬於舊版模式，ADK 在收到模型發出的 `turn_complete=True` 事件時，會自動對隊列呼叫 `close()`。

**導師建議**：在開發 BIDI 應用程式時，不要依賴系統自動清理。手動呼叫 `close()` 是構建反應迅速、具備生產能力之應用程式的基礎。

---

### 五、 知識延伸與收斂

在結束這份教學之前，請務必記住以下三條「導師守則」：

1.  **隊列的唯一性**：`LiveRequestQueue` 是對話特定且有狀態的。**切勿重複使用隊列**，因為關閉訊號會留在隊列中，導致新的會話立即終止。
2.  **清理是義務**：未呼叫 `close()` 是導致「並行會話配額不足」最常見的幕後黑手。
3.  **非同步連鎖反應**：呼叫 `close()` 會讓 `run_live()` 結束產生事件，進而導致 `downstream_task` 的 `async for` 迴圈結束，這是一套連鎖的優雅清理流程。

**總結：**
階段 4 是應用程式生命週期的完美句點。透過主動終止，我們確保了 Live API 平台的資源能被高效回收。現在你已經掌握了從初始化到優雅終止的完整架構，可以開始構建具備生產實力的低延遲 AI 代理程式了！

#SessionTermination #ResourceCleanup #ZombieSessions #ADKArchitecture #LiveRequestQueue