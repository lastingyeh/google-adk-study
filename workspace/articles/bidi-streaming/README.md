# 雙向串流 (Bidi-streaming) 深度實作指南

歡迎來到這堂深度技術實作課。我是你們的資深技術導師。今天我們要探討的是 ADK（Agent Development Kit）中最具革命性的技術核心：**雙向串流 (Bidi-streaming)**。

在傳統的 AI 互動中，我們習慣了「提問並等待」的模式，這就像是在發送電子郵件。而 ADK 的雙向串流則將這種互動轉化為如同「電話交談」般的體驗——流暢、自然，且具備即時中斷、澄清與回應的能力。這不僅是技術的升級，更是人機互動範式的根本轉變。

## 📌 ADK 雙向串流學習地圖

1.  **核心哲學與模式對比**：理解雙向串流與 SSE、Token 級別串流的本質差異。
2.  **ADK 架構四階段生命週期**：掌握從應用程式初始化到對話終止的完整流程。
3.  **場景驅動教學**：透過中斷處理、多模態感知與穩定性維護三大實戰場景深入解析。
4.  **技術實作細節**：解析 `LiveRequestQueue`（上行）與 `run_live()`（下行）的協作。
5.  **性能與生產化建議**：如何優化二進位傳輸與管理工作階段恢復。

---

### 一、 邏輯具象化：串流技術模式對比

為了讓大家一眼看清雙向串流的獨特價值，我們根據來源資料整理了這份對照表：

| 串流類型               | 通訊方向                   | 互動性                     | 使用場景                     |
| :--------------------- | :------------------------- | :------------------------- | :--------------------------- |
| **伺服器端串流 (SSE)** | 單向（伺服器 → 客戶端）    | 無法即時互動，僅接收資料   | 直播影片、儀表板更新         |
| **Token 級別串流**     | 單向（文字逐字生成）       | 不可中斷，需等待回應完成   | 傳統聊天機器人（打字機效果） |
| **雙向串流 (Bidi)**    | **雙向（同步發送與接收）** | **具備中斷支援，即時反應** | 自然對話式 AI、語音代理      |

---

### 二、 場景驅動教學：將抽象架構轉化為實戰體驗

#### 💡 場景一：實現「人類般」的自然中斷處理
**問：** 「導師，如果 AI 正在長篇大論解釋量子物理，而使用者突然想問『等等，電子是什麼？』，系統該如何反應？」
**解析：** 這是雙向串流中最關鍵的 **「回應式中斷 (Responsive Interruption)」** 功能。
*   **這代表什麼？** 在雙向串流中，AI 不需要等到話說完才接收新輸入。
*   **關鍵在於：** 系統內建的 **語音活動偵測 (VAD)** 能自動判斷使用者何時開始說話，並產生 `interrupted=True` 事件。
*   **解決方案：** 當下游接收到中斷標記時，UI 應立即停止呈現過時內容並清空音訊緩衝區。

#### 💡 場景二：賦予 AI 「眼睛」的多模態購物導購 (Shopper's Concierge)
**問：** 「在電子商務中，AI 如何主動根據我目前的環境推薦產品？」
**解析：** 這展示了 ADK 的 **視覺感知 (Vision Capabilities)** 能力。
*   **實作細節：** 系統能以每秒處理一張圖像（1 FPS）的頻率分析影像序列。
*   **場景模擬：** AI 透過攝像頭看到使用者的書桌上有筆電，會「主動」詢問是否需要螢幕架或檯燈，而非僅僅被動等待文字指令。

#### 💡 場景三：應對「10 分鐘限制」的生產級穩定性
**問：** 「我聽說 Live API 的 WebSocket 有連線持續時間限制（約 10 分鐘），這會導致對話中斷嗎？」
**解析：** 這就是為什麼我們需要 **工作階段恢復 (Session Resumption)**。
*   **技術真相：** 單個連線雖然會自動終止，但 **會話 (Session)** 是可以跨越連線存在的。
*   **ADK 的價值：** ADK 透過 `RunConfig` 自動化了恢復過程。它會自動快取恢復句柄，在連線斷開時「透明地」重新連線，使用者完全不會察覺。

---

### 三、 代碼即真理：解構核心串流邏輯

在 ADK 中，雙向串流的靈魂在於 **「並行任務」** 的設計：上行（發送）與下行（接收）必須同時運作。

#### 1. 下行任務：使用 `run_live()` 處理事件
這是從模型接收 Event 物件的動脈。

```python
# [導師點評]：run_live() 是一個非同步產生器，它讓「事件」成為通訊的最小單位。
# 我們不需要手動處理 WebSocket 協定，ADK 會將其封裝為 Event 對象。

async def downstream_task() -> None:
    logger.debug("下行任務啟動，呼叫 runner.run_live()")
    async for event in runner.run_live(
        user_id=user_id,
        session_id=session_id,
        live_request_queue=live_request_queue, # 上行隊列
        run_config=run_config,                 # 配置參數
    ):
        # [關鍵在此]：將事件序列化為 JSON 透過 WebSocket 傳送給用戶端
        # model_dump_json 會自動處理 Pydantic 模型的轉換
        event_json = event.model_dump_json(exclude_none=True, by_alias=True)
        await websocket.send_text(event_json)
```
*(參考來源：)*

#### 2. 用戶端處理：解析中斷與內容
當用戶端接收到事件後，必須正確回應標記。

```javascript
// [導師點評]：這是處理「插嘴」的標準動作。
// 當接收到 interrupted 標記時，我們必須立即停止音訊播放並清除 UI 狀態。

if (adkEvent.interrupted === true) {
    // [關鍵在此]：立即停止音訊播放器的運作
    if (audioPlayerNode) {
        audioPlayerNode.port.postMessage({ command: "endOfAudio" });
    }
    // 標記氣泡為「已中斷」，提供視覺反饋
    if (currentBubbleElement) {
        currentBubbleElement.classList.add("interrupted");
    }
    // ... 重設狀態以建立新的氣泡
}
```
*(參考來源：)*

---

### 四、 性能優化建議：音訊傳輸的關鍵

在處理音訊時，我們需要注意 **Base64 編碼的開銷**。將二進位資料放入 JSON 傳輸會增加約 133% 的開銷。

*   **優化方案：** 對於音訊密集型應用，建議在用戶端使用 Web Audio API，並透過 **WebSocket 二進位框架 (Binary Frames)** 直接傳送 16kHz PCM 資料。
*   **規格提醒：**
    *   **輸入音訊：** 16kHz 單聲道 PCM。
    *   **輸出音訊：** 24kHz 單聲道 PCM（原生音訊模型）。

---

### 🏁 知識收斂與實戰總結

ADK 的雙向串流功能透過封裝複雜的 WebSocket 連線管理、自動工具執行與 VAD 偵測，將原本需要數月開發的基礎設施工作簡化為「宣告式配置」。

**核心資源歸納：**
*   **開發入口：** 使用 `RunConfig` 設定 `StreamingMode.BIDI` 以開啟低延遲模式。
*   **穩定性保證：** 必須啟用 `SessionResumptionConfig` 以應對網絡不穩定。
*   **多模態處理：** 使用 `LiveRequestQueue.send_realtime()` 發送音訊塊或 JPEG 影格（建議 1 FPS, 768x768）。

**導師的話：** 「雙向串流的魅力在於它的『不確定性』——人類可以在任何時刻介入，這才是真正的對話。作為開發者，你的任務是利用 ADK 提供的標記（如 `partial`、`interrupted`），構建一個能優雅應對這些互動的響應式介面。」

---
### 🚀 讓我們一起進入這個課程，掌握雙向串流的奧秘，打造出前所未有的 AI 互動體驗吧！ GO! 🚀 →→ [課程開始](COURSE_PLAN.md)

🏷️ `bidi-streaming`, `gemini-live-api`, `ai-agent`, `native-multimodal`, `real-time-ai`
