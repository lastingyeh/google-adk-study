# STOP Using MCP Like This, Use MCP 2.0 Instead (Save 98% More Tokens) 重點筆記

## **停止低效使用 MCP：採用程式碼執行（MCP 2.0）範式，節省 98% 的 Token 消耗**

### **摘要與引言**

Anthropic 最近發佈了一項關於**模型上下文協定（Model Context Protocol, MCP）**的重大發現，對於所有建構 AI 代理（AI Agents）的人來說至關重要。傳統上，MCP 已成為連接 AI 代理與外部工具和資料來源的業界標準。然而，普遍使用的 MCP 方式被認為是**根本上低效的**，可能導致代理產生幻覺（Hallucinating）、 Token 成本飆升失控、工作流程因上下文限制而隨機中斷。

這種低效的方法可能會多燒掉 **98%** 的 Token。新提出的「程式碼執行」（Code Execution）方法並非要求學習新工具，而是一種完全不同的思維方式，用於思考代理如何與 MCP 伺服器互動，從而解決了所有這些問題。

### **傳統 MCP 的挑戰與經濟問題**

傳統上，MCP 伺服器的廣泛建立使得代理能夠通用地連接到 Gmail、Slack、資料庫或 CRM 等系統。然而，當為真實客戶建構複雜系統並投入生產時，會出現以下重大問題：

#### 1. 上下文混亂與準確性下降

*   **定義泛濫：**在複雜的專案中，客戶系統可能需要連接六個不同的系統（例如，法律文件搜尋、日曆更新、CRM 紀錄等）。每個 MCP 伺服器可能包含 15 到 20 個工具，總共超過 **100 個不同的功能**。
*   ** Token 消耗過度：**即使代理僅需使用其中三到四個工具來完成特定任務，所有 **100 個工具的定義**（包括描述、所需參數、可選參數、回傳類型和範例）都會從一開始就載入到代理的上下文視窗中。
*   這導致數萬個 Token 閒置，使成本立即提高、回應時間變慢。
*   **錯誤率增加：**當上下文過於混亂時，代理會做出更多錯誤。它可能會對使用哪個工具感到困惑，幻覺出不存在的參數，或以不合邏輯的方式呼叫工具。當有 100 個工具定義爭奪注意力時，代理的準確性會大幅下降。

#### 2. 重複處理與資料過載

*   **重複付費：**如果代理需要從文件系統中提取一份 40,000 個 Token 的證詞謄本，傳統方法會將**整個謄本**載入到代理的上下文中。如果代理隨後需要將關鍵點摘要並更新到 CRM 系統中，這 40,000 個 Token 的資料會再次被處理。這意味著使用者**多次為相同的資料流經上下文付費**。
*   **上下文限制：**當工作流程涉及跨系統的多項操作串聯時，很容易達到上下文視窗限制，或在工作流程完成前就耗盡 API 預算。在某些專案中， Token 成本甚至可能使整個專案的經濟效益令人質疑。

### **程式碼執行 (Code Execution)：解決方案**

程式碼執行改變了遊戲規則，其核心在於理解 **AI 模型最佳的運作方式**。

#### 1. 機制與設計

*   **檔案系統呈現：**不再將 MCP 工具呈現為代理直接進行的函式呼叫，而是將它們呈現為一個代理可以探索的**檔案系統**。
*   **TypeScript 檔案：**每個 MCP 伺服器變成一個資料夾，伺服器中的每個工具都是一個 **TypeScript 檔案**。
*   **程式碼撰寫：**代理可以搜尋結構，找到它需要的確切工具，然後**撰寫程式碼**來使用這些特定工具。

#### 2. 模型優勢

*   AI 模型在其預訓練階段是**接受了大量程式碼訓練的**（數百萬行）。
*   工具呼叫（Tool Calling）是在後續訓練階段才學習到的，計算量較少。
*   讓代理撰寫程式碼來與 MCP 伺服器互動，是**利用了模型最擅長的能力**，而不是將其限制在一個不那麼自然的僵化結構中。

### **工作流程比較與關鍵優勢**

程式碼執行方法的核心差異在於**資料處理**和**上下文管理**。

| 特點 | 傳統 MCP 方法 | 程式碼執行方法 (Code Execution) | 引用 |
| :--- | :--- | :--- | :--- |
| **工具載入** | 所有工具定義從開始即載入到上下文視窗中，造成混亂。 | 代理只載入**所需的特定工具定義**，而不是所有伺服器的所有工具。 | |
| **資料流動** | 40,000  Token 的資料全部進入上下文，佔用空間並重複處理。 | 資料結果保留在**沙盒（Sandbox）變數中**，位於代理上下文之外。 | |
| **資料處理** | 代理在上下文視窗中努力處理和計算任務。 | 代理在沙盒環境中撰寫程式碼來**過濾、轉換和提取**資料。 | |
| **上下文返回** | 處理前的全部資料返回至上下文。 | **只有最終處理後的結果**（例如，40,000  Token 變成 500  Token ）返回到代理上下文。 | |
| **成本/可靠性** | 成本高昂，代理因資料過載而犯錯。 | 成本大幅降低（例如，40,000  Token 的兩次流程總共只需約 2,000  Token ），且可靠性更高。 | |

**類比說明：**傳統 MCP 就像被迫隨身攜帶工具箱裡的所有工具，並且在使用任何單個工具之前都必須大聲朗讀所有說明書。程式碼執行就像擁有一個工作坊，您可以走到正確的區域，準確地抓取所需的工具，並在沙盒中完成您的專案，只向外界展示最終結果。

### **商業影響與關鍵優勢**

程式碼執行模式對企業或客戶業務的實際影響是巨大的。

1.  **改變經濟效益：**傳統方法下的自動化（例如，每天處理 200 張工單）API 成本可能高達每天 $400 到 $600；而程式碼執行可以將其降低到每天 **$40 到 $60**。這使得投資回報率（ROI）變得可行，並允許客戶大規模運行。
2.  **實現不可能的專案：**由於成本和可靠性限制，以前無法建構的複雜項目現在變得可行。例如，監控跨 Shopify、Amazon 和會計軟體的電子商務庫存水平。程式碼執行只返回推薦的補貨行動（約 1,000 個 Token ），而不是 150,000 個 Token 的資料流。
3.  **隱私與合規性：**對於企業級客戶（如醫療、金融、法律事務所）來說，隱私成為一個巨大的賣點。敏感資料**永遠不會真正接觸到** Anthropic 或 OpenAI 伺服器，它停留在沙盒環境中。可以設定自動 Token 化，模型只看到替代標籤（如 `customer_emil1`），而不是實際電子郵件地址。這為受監管行業解鎖了交易。
4.  **代理學習與進化：**代理可以在檔案系統中工作，儲存它撰寫的有用程式碼（例如，解析特定文件格式的聰明方法）作為可重複使用的函式。隨著時間的推移，代理可以建立自己的解決方案庫，**進化其自身的能力**，不必每次都從零開始。

### **程式碼執行的弊端與注意事項**

雖然優勢顯著，但程式碼執行並非沒有缺點，需要注意以下兩點：

1.  **潛在可靠性問題：**傳統 MCP 呼叫是僵化但可預測的（要麼成功，要麼拋出一個直接的錯誤）。程式碼執行要求代理**每次都撰寫系統正確的程式碼**，這引入了語法錯誤、邏輯錯誤或邊緣情況錯誤的風險。例如，代理可能在 19 次運行中完美無缺，但在資料格式稍有不同時，第 20 次運行就會失敗。這需要更好的測試、錯誤處理和監控系統。
2.  **基礎設施開銷：**不能簡單地將其部署到無伺服器函式上。它需要一個**適當、安全且隔離的沙盒環境**，對程式碼的行為和資源消耗設有嚴格限制。這涉及到真正的 DevOps 工作。雖然這對於處理實際業務流程的生產系統是必要的，但對於執行一兩項簡單任務的聊天機器人來說，這種基礎設施是**過度的**。

### **應用場景與決策框架**

如何選擇方法取決於項目的複雜性、數據量和對成本/可靠性的要求。

#### 1. 繼續使用傳統 MCP 的時機

*   **簡單用例：**只需要一到兩次或最多三次工具呼叫的情況。
*   **低流量操作：** Token 成本在整體考量中並不重要的情況。
*   **快速原型與 MVP：**需要快速推進並驗證概念的場景。
*   **極致可靠性優先：**在絕對可靠性比成本優化更重要的情況下。

#### 2. 採用程式碼執行的時機

*   **複雜工作流程：**涉及大量資料處理或轉換的情況。
*   **高流量操作：**成本會迅速複合且影響巨大的情況。
*   **企業級客戶：**具有嚴格隱私和合規性要求（如 HIPAA）的客戶。
*   **上下文限制：**工作流程不斷達到上下文視窗限制的情況。
*   **非結構化數據：**需要代理處理混亂、不可預測且格式不一的數據。
*   **生產系統：**要求代理具備高可靠性，且不會因為上下文過載而產生幻覺或錯誤。

**個人經驗法則：**如果整個系統可以使用**少於 10 次工具呼叫**來建構，並且傳遞的資料量相對較小，那麼堅持使用傳統 MCP，保持簡單即可。但如果涉及複雜操作的串聯、處理大量資料，或需要一個**防彈的生產系統**，則程式碼執行絕對值得在基礎設施和設定時間上進行前期投資。

---
### **延伸學習**：[連結](./2-STOP%20Using%20MCP%20Like%20This,%20Use%20MCP%202.0%20Instead%20(Save%2098%25%20More%20Tokens).md)

---

### **參考來源**

- [使用 MCP 執行程式碼：建構更有效率的 AI Agents](./code-execution-with-mcp-building-more-efficient-agents.md)
- [STOP Using MCP Like This, Use MCP 2.0 Instead (Save 98% More Tokens)](https://youtu.be/jJMbz-xziZI?si=H77UrCQDVGYqfHH-)
