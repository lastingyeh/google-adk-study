# GEPA 演化式提示最佳化：從模擬到實踐

本文檔旨在分析 `gepa_demo.py` 和 `gepa_real_demo.py` 兩個腳本，解釋其背後的 GEPA (Genetic Prompt Algorithm) 概念，並比較模擬展示與真實執行的差異。

## 什麼是 GEPA？

GEPA 是一種系統性的、數據驅動的演算法，用於自動化地「演化」和「最佳化」大型語言模型 (LLM) 的提示 (Prompt)。相較於手動猜測和修改提示，GEPA 採用了類似遺傳演算法的五步驟循環，以系統化的方式提升提示的效能和強健性。

### GEPA 的五步驟演算法循環

1.  **收集 (COLLECT):** 使用當前的提示，針對一組預定義的「評估情境」(測試案例) 執行代理，並收集其成功或失敗的結果。
2.  **反思 (REFLECT):** 使用一個強大的 LLM (反思模型) 來分析失敗的案例，找出提示中缺失或模糊的指令，並總結出根本原因。
3.  **演化 (EVOLVE):** 根據反思階段得出的洞察，讓 LLM 自動「重寫」或「演化」出一個新的、改進版的提示，旨在修復已識別的缺陷。
4.  **評估 (EVALUATE):** 使用新的「演化後提示」再次執行相同的評估情境，並量化其效能是否有所提升。
5.  **選擇 (SELECT):** 如果演化後的提示表現優于舊版本，則保留它作為下一次迭代的「種子提示」。此過程可重複進行，直到提示的效能收斂或達到預算上限。

---

## 檔案分析

工作區中的兩個 Python 腳本分別展示了 GEPA 的兩種不同層面：概念教學與實際應用。

### 1. `gepa_demo.py` - 模擬展示

此腳本是一個**教學工具**，旨在清晰地展示 GEPA 的核心思想，而無需實際呼叫 LLM API，因此沒有任何執行成本。

#### 目的

-   教育使用者了解 GEPA 的五步驟循環。
-   展示一個「弱」的種子提示如何演化成一個「強健」的提示。
-   解釋提示演化前後的具體差異以及改進的原因。

#### 運作方式

-   **模擬評估:** 它不執行真實的 LLM 代理，而是使用一個名為 `evaluate_scenario` 的函式來「模擬」提示在不同情境下的表現。此函式根據提示文本中是否包含特定關鍵字 (如 `verify`, `30`, `security`) 來判斷成功或失敗。
-   **預定義內容:**
    -   `INITIAL_PROMPT`: 一個刻意設計得比較薄弱的初始提示。
    -   `EVOLVED_PROMPT`: 一個手動編寫的、理想化的「演化後」提示。
    -   `REFLECTION`: 一段預先寫好的文字，用來解釋種子提示失敗的原因。

#### 重點摘要

-   **清晰的對比:** 非常直觀地展示了從一個通用、模糊的提示演化為一個包含明確安全協定、政策規則和逐步程序的強健提示。
-   **解釋性強:** 透過 `REFLECTION` 變數，明確指出了初始提示的缺陷（如缺少身份驗證、政策不清晰等），幫助使用者理解「為什麼」需要改進。
-   **零成本學習:** 由於所有內容都是預定義和模擬的，因此是理解 GEPA 概念的絕佳起點。

### 2. `gepa_real_demo.py` - 真實世界展示

此腳本是一個**功能展示**，它使用真實的 Google Gemini API 來執行完整的 GEPA 最佳化循環。

#### 目的

-   展示 GEPA 如何在真實世界中自動化地最佳化提示。
-   證明 LLM 本身有能力根據失敗案例進行「反思」並「演化」出更優的提示。
-   提供一個可用於生產環境的 GEPA 最佳化器 (`RealGEPAOptimizer`) 的實際範例。

#### 運作方式

-   **真實 LLM 呼叫:**
    -   **代理模型 (`gemini-2.5-flash`):** 用於在「收集」和「評估」階段執行代理，處理客戶輸入。
    -   **反思模型 (`gemini-2.5-pro`):** 一個更強大的模型，用於在「反思」和「演化」階段分析失敗並生成新的提示。
-   **自動化循環:** `RealGEPAOptimizer` 類別封裝了完整的五步驟循環。它會自動執行多次迭代（預設為 2 次），並在每次迭代中嘗試產生一個更好的提示。
-   **動態結果:** 每次執行此腳本，最終生成的 `final_prompt` 都可能略有不同，因為它是 LLM 動態生成的，而非預先定義的。

#### 重點摘要

-   **自動化與自主性:** 完美展示了 GEPA 的強大之處——整個最佳化過程是自動的。提示的改進不是來自人類的手動調整，而是來自 LLM 對自身失敗的「學習」。
-   **數據驅動的改進:** 最終的提示是基於在多個 `EVALUATION_SCENARIOS` 上的實際表現數據演化而來的，確保了改進是具體且有效的。
-   **生產就緒:** 雖然此展示為了速度而簡化了迭代次數，但其背後的 `RealGEPAOptimizer` 和流程是可以在生產環境中擴展使用的，例如透過排程定期執行來持續改進關鍵提示。

---

## 流程比較

| 特性 (Feature) | `gepa_demo.py` (模擬)    | `gepa_real_demo.py` (真實)                   |
| :------------- | :----------------------- | :------------------------------------------- |
| **目標**       | 教育與概念展示           | 實際的自動化提示最佳化                       |
| **演化方式**   | 手動預定義的理想提示     | LLM 根據反思自動生成                         |
| **評估方式**   | 模擬的、基於關鍵字的邏輯 | 真實的 LLM 代理執行與評估                    |
| **反思方式**   | 預先寫好的靜態分析       | LLM 動態分析失敗案例                         |
| **API 成本**   | **無** (無 API 呼叫)     | **低** (實際 API 呼叫，可透過 `budget` 控制) |
| **結果**       | 固定的、可預測的         | 動態的、每次執行可能不同                     |
| **主要價值**   | 幫助理解「什麼是 GEPA」  | 證明「GEPA 如何實際運作」                    |

## 總結與後續步驟

`gepa_demo.py` 和 `gepa_real_demo.py` 共同構成了一個完整的 GEPA 學習路徑：

1.  **從 `gepa_demo.py` 開始:** 透過模擬展示，快速、無成本地掌握 GEPA 的核心思想和五步驟循環。
2.  **接著運行 `gepa_real_demo.py`:** 在理解了基本概念後，觀察並體驗一個真實的、由 LLM 驅動的自動化提示最佳化流程。

GEPA 是一個強大的工具，它將提示工程從一門「藝術」轉變為一門更具系統性和數據支持的「科學」。透過自動化的方式識別缺陷、進行反思並迭代改進，開發者可以更高效地創造出在各種邊界情況下都表現強健的提示。
