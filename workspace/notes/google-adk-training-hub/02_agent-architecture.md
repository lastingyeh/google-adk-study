這份文件深入探討了 **Google ADK (Agent Development Kit)** 中關於代理程式架構、層級模型和狀態管理策略的組成與最佳實踐。

---

## 🎯 重點摘要（Key Takeaways）

根據資料，代理程式架構與狀態管理策略的主要重點包含五個領域：

### 1. 代理程式類型（Agent Types）

ADK 中主要有三種代理程式類型，應根據用途選擇：LLM 代理程式適用於彈性需求、工作流程代理程式適用於既定流程，而遠端代理程式則適用於專業化需求。

| 類型                 | 心智模型 (Mental Model)                                      | 用途                                                                                                                                                      | 特性                                                                                                                 |
| :------------------- | :----------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------- |
| **LLM 代理程式**     | **思考者模式 (Thinker Pattern)**：動態推理的靈活問題解決者。 | 適用於對話式介面、創意問題解決、分析與推理任務，以及動態決策制定。                                                                                        | **靈活**（適應新情況）、**創意**（產生新穎方案）、**工具感知**（可按順序呼叫多個工具）、**有狀態**（維護對話內容）。 |
| **工作流程代理程式** | **管理者模式 (Manager Pattern)**：遵循預定義流程的協調者。   | 適用於可預測的多步驟流程、品質保證工作流程、複雜的流程編排和批次處理。可分為順序（`SequentialAgent`）、平行（`ParallelAgent`）或迴圈（`LoopAgent`）流程。 | N/A                                                                                                                  |
| **遠端代理程式**     | **服務模式 (Service Pattern)**：透過 HTTP 存取的外部專家。   | 適用於專業領域知識、微服務架構、跨團隊協作以及可擴展的代理程式生態系統。可被整合為本地工作流程中的工具。                                                  | N/A                                                                                                                  |

### 2. 代理程式層級模型（Agent Hierarchy Model）

代理程式遵循「單一父層規則」（Single Parent Rule），形成類似公司結構的清晰組織樹狀圖。

*   **單一父層規則**：每個代理程式只會有一個父層。
*   **共享狀態**：父層和子層透過 `state['key']` 共享**會話狀態**。
*   **清晰通訊**：透過狀態鍵或 `transfer_to_agent()` 進行任務交接。
*   **範圍化執行**：子層會繼承父層的調用上下文。

### 3. 狀態與記憶管理（State Management）

管理代理程式的資料，涉及短期工作記憶（狀態）和長期機構知識（記憶）。

#### 會話狀態 (Session State / RAM - 短期)
這是用於當前對話的工作記憶。

*   **範圍**：僅限當前會話。
*   **持久性**：會話結束時丟失。
*   **用例**：對話上下文、工作資料、使用者偏好。
*   **狀態範圍前綴**：
    *   `state['key']`：會話範圍（此對話）。
    *   `state['user:key']`：使用者範圍（所有使用者會話）。
    *   `state['app:key']`：應用程式範圍（整個應用程式）。
    *   `state['temp:key']`：臨時範圍（僅限此次調用）。

#### 記憶服務 (Memory Service / Hard Drive - 長期)
這是跨所有對話的機構知識。

*   **範圍**：適用於使用者/應用程式的所有會話。
*   **持久性**：永久儲存。
*   **用例**：歷史知識、使用者模式、學習到的偏好。

#### 大型內容的 Artifacts
這是一種用於處理大型資料的檔案系統。

*   **用途**：儲存大型文字文件、二進位檔案（圖像、PDF）、生成的內容和持久性檔案儲存。當資料過大時，應將內容儲存為 Artifact，並將其 ID 參考儲存在狀態中（例如 `state['report_id']`）。

### 4. 代理程式通訊模式（Communication Patterns）

代理程式之間有三種主要溝通方式：

1.  **直接狀態轉移 (Direct State Transfer)**：代理程式 A 將輸出寫入狀態（使用 `output_key`），代理程式 B 則透過狀態內插 (state interpolation) 讀取該資料，從而實現溝通。
2.  **工具式通訊 (Tool-Based Communication)**：透過將一個代理程式轉換為工具（`AgentTool`），讓另一個代理程式可以在需要專業知識時呼叫它。
3.  **基於回呼的協調 (Callback-Based Coordination)**：定義一個回呼函數（例如 `on_agent_complete`），在代理程式完成工作後執行特定操作，用於跨代理程式的協調。

### 5. 架構組合最佳實踐（Composition Best Practices）

在設計代理程式系統時，應遵循以下原則和優化策略：

#### 分層設計原則
1.  **單一職責 (Single Responsibility)**：每個代理程式都應有一個明確的目的。
2.  **清晰介面 (Clean Interfaces)**：透過狀態鍵進行通訊，而非直接呼叫。
3.  **範圍狀態 (Scoped State)**：使用適當的狀態前綴（`temp:`、`user:`、`app:`）。
4.  **錯誤邊界 (Error Boundaries)**：將故障隔離在代理程式邊界內。

#### 效能優化
*   **盡可能使用平行處理**：獨立的任務應使用 `ParallelAgent`。
*   **相依任務使用順序處理**：任務之間存在結果依賴時，應使用 `SequentialAgent`。

#### 除錯與常見問題
*   **狀態檢查 (State Inspection)**：使用內建的除錯鍵（例如 `{debug:state}` 和 `{debug:keys}`）來分析執行時的狀態。
*   **事件追蹤 (Event Tracing)**：啟用詳細的事件日誌（如 `AGENT_START`, `LLM_REQUEST`, `STATE_CHANGE`）來追蹤系統。
*   **常見問題與解決方案**：
    *   狀態未共享：使用 `output_key` 和狀態內插。
    *   記憶體洩漏：對臨時資料使用 `temp:` 前綴。
    *   循環依賴：重新設計層級結構或使用 `ParallelAgent`。
    *   效能下降：增加 `ParallelAgent` 或減少狀態大小。